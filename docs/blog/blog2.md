### Intro

Since the proposal has been accepted, a lot of research has gone into the project in lieu of the functional specification document. This blog is to be used as a weekly development diary where aspects of the project can be elaborated on and where choices in design and implementation can be explained. The blog contents in markdown will be posted to my gitlab repository [here](https://gitlab.computing.dcu.ie/morrip25/2018-ca400-morrip25/tree/master/docs/blog) but it is much easier read from this [website](http://46.101.45.240:4000/blog/).

## The Tally

One aspect of e-voting systems is how the counts are to be voted. What I think is going to be the best solution is an application of hommorphic encryption. Hommomorphic encryption is where two plaintexts are encrypted using a public key. The resulting ciphertexts can be computed together, in our case only the additive property is neccessary. The sum of the ciphertexts can be decrypted using the private key and the result is equal to the sum of the two plaintexts. Visually:

$$
D(E(1) + E(2)) = 1 + 2
$$

An example of how it works in an election process is where a two candidate system where one candidate is represented by a **0** and the other candidate, a **1**. The voters choose a candidate based on their numeric value and encrypt their vote using the public-key, the votes are collated together and computed by an authority. The encrypted sum is still a random ciphertext value and the private-key is applied to decrypt it. What value is returned is the number of votes for the candidate represented by **1**.  As all candidates who voted 1 as their choice, their vote will be counted, whereas the votes encrypted as 0 will not affect this count.
The winner can be generated by finding the difference between the decrypted result and the sum of the votes. As subtracting the number of **1's** from the number of voters will generate the number of votes for the candidate with value **0**.

## Multiple Candidates

As mentioned, this system is useful in a scenario of two candidates but the question lies with how can it be implemented with a multiple candidates for an election. My idea to handle this draws from the fact that the number of **1's** were always represented regardless of the other candidates vote as theirs was always equal to 0. If we know before hand the number of voters participating in the election it is possible to manipulate the numeric value representing the candidates. Supposing two candidates and a 1000 participating voters.
Instead of writing their voting values as **0** and **1**, we can write it as **1** and **10,000**.

\\(\text{Number of candidates } N = 1000\\)
\\(\text{Voting value for Candidate A} = 1\\)
\\(\text{Voting value for Candidate B} = 10000\\)

Supposing that both A and B split the votes and the election is a draw. The decrypted value would appear as:

$$
(1 \times 500) + (10000 \times 500) \\= 5000500
$$

We can formulate \\(N\\) to be represented as \\(1 \times 10^k\\), where in this case, \\(k = 3\\). Working right to left across the decrypted sum, we can generate the tally for each individual candidate by taking the rightmost \\(k+1\\) digits. 

\\(\text{Votes for Candidate A} = 500\\)

\\(\text{Votes for Candidate B} = 500\\)

A scenario for three candidates would look like this. Supposing also that Candidate B got half the votes and the other two got a quarter each.

\\(\text{Number of candidates } N = 1000\\)

\\(\text{Voting value for Candidate A} = 1\\)

\\(\text{Voting value for Candidate B} = 10000\\)

\\(\text{Voting value for Candidate C} = 100000000\\)

$$
(1 \times 250) + (10000 \times 500) + (1 0000 0000 \times 250)= 25005000250 \\
0250\ 0500 \ 0250\\
\ A \ \ \ \ \ B \ \ \ \ \ C
$$

## Generating Candidate numerics

Where \\(N = \\) number of voters, we can represent it as:

$$
N = n \times 10^ k \ | \ n \leq 1
$$

The voting numeric for each candidate can then be equated by first ordering them and for every \\(i\\) candidates, a candidates value:

$$
candidate[i] = 1 \times 10^{(k + 1)^i} \ | \ i > 0
$$

The decrypted sum takes the rightmost \\(k+1\\) digits for each candidate for their result.
